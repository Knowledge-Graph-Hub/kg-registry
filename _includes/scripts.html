<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://d3js.org/d3.v7.min.js"></script>

<!-- prism.js is for code blocks, see https://prismjs.com -->
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

<script>
    document.addEventListener('DOMContentLoaded', function () {
        // Call the async function without waiting for it
        renderProvenanceDiagrams().catch(console.error);

        // Add window resize listener to adjust diagrams on window resize
        window.addEventListener('resize', function () {
            // Debounce the resize event
            if (this.resizeTimeout) clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(function () {
                renderProvenanceDiagrams().catch(console.error);
            }, 200);
        });
    });

    // Function to fetch resource category and icon
    async function fetchCategoryIcon(resourceId) {
        try {
            const response = await fetch(`/kg-registry/resource/${resourceId}/${resourceId}.html`);
            if (!response.ok) {
                return { category: 'unknown', icon: 'box' };
            }
            const html = await response.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Look for the header with the icon
            const header = doc.querySelector('h1 .bi');
            if (header) {
                const iconClass = header.className;
                // Extract the icon name from "bi bi-iconname"
                const iconName = iconClass.replace('bi bi-', '');
                return { category: 'found', icon: iconName };
            }
            
            return { category: 'unknown', icon: 'box' };
        } catch (error) {
            console.error('Error fetching resource category:', error);
            return { category: 'error', icon: 'box' };
        }
    }

    // Category to icon mapping
    const categoryIcons = {
        "Aggregator": "grid-3x3",
        "Resource": "archive",
        "KnowledgeGraph": "globe",
        "DataSource": "shop",
        "DataModel": "diagram-3",
        "GraphProduct": "globe",
        "Product": "box",
        "MappingProduct": "map",
        "ProcessProduct": "gear",
        "DataModelProduct": "diagram-3",
        "GraphicalInterface": "window",
        "ProgrammingInterface": "code-square"
    };

    // D3.js Provenance Diagram renderer
    async function renderProvenanceDiagrams() {
        const provenanceContainers = document.querySelectorAll('.provenance-diagram');
        
        for (const container of provenanceContainers) {
            const data = JSON.parse(container.getAttribute('data-provenance'));

            // Calculate appropriate height based on number of sources
            const originalSourceCount = data.originalSources ? data.originalSources.length : 0;
            const secondarySourceCount = data.secondarySources ? data.secondarySources.length : 0;

            // Base height + additional height per source (with some minimum)
            const minHeight = 300; // Minimum height
            const heightPerSource = 70; // Add this much height per source

            // Calculate height based on whichever is larger: original or secondary sources
            const calculatedHeight = Math.max(
                minHeight,
                Math.max(originalSourceCount, secondarySourceCount) * heightPerSource + 100
            );

            // Set height on the container
            container.style.height = `${calculatedHeight}px`;

            // Render the diagram with the calculated height
            await renderD3Diagram(container, data, calculatedHeight);

            // Also set the height on the parent card
            const cardBody = container.closest('.card-body');
            if (cardBody) {
                cardBody.style.minHeight = `${calculatedHeight + 70}px`; // Add some extra padding
            }
        }
    }

    async function renderD3Diagram(container, data, height) {
        // Clear any existing content
        container.innerHTML = '';

        // Set up dimensions and spacing
        const width = 600;
        // Use the dynamic height passed from the parent function
        const nodeWidth = 150;
        const nodeHeight = 50; // Increased node height for better text fit
        const nodePadding = 50;
        
        // Preload category icons for each resource
        const resourceIcons = {};
        
        // Add product category icon - we know it's a product type already
        const productCategory = container.getAttribute('data-product-category');
        const productIcon = container.getAttribute('data-product-icon');
        
        if (productCategory && productIcon) {
            // Use the category and icon from the data attributes
            resourceIcons[data.product] = { 
                category: productCategory, 
                icon: productIcon
            };
        } else {
            // Fallback to default Product icon
            resourceIcons[data.product] = { 
                category: 'Product', 
                icon: categoryIcons['Product'] || 'box' 
            };
        }
        
        // Load all source icons asynchronously
        const fetchPromises = [];
        
        // Load original source icons
        if (data.originalSources && data.originalSources.length > 0) {
            for (const source of data.originalSources) {
                fetchPromises.push(
                    fetchCategoryIcon(source).then(result => {
                        resourceIcons[source] = result;
                    })
                );
            }
        }
        
        // Load secondary source icons
        if (data.secondarySources && data.secondarySources.length > 0) {
            for (const source of data.secondarySources) {
                fetchPromises.push(
                    fetchCategoryIcon(source).then(result => {
                        resourceIcons[source] = result;
                    })
                );
            }
        }
        
        // Wait for all icon data to be loaded
        await Promise.all(fetchPromises);

        // Create SVG
        const svg = d3.select(container)
            .append('svg')
            .attr('width', width)
            .attr('height', height)
            .attr('class', 'provenance-svg');

        // Create a group for the entire diagram
        const g = svg.append('g')
            .attr('transform', 'translate(10, 20)');

        // Add a subtle data flow indicator
        svg.append('text')
            .attr('class', 'direction-indicator')
            .attr('x', width / 2)
            .attr('y', height - 10)
            .attr('text-anchor', 'middle')
            .attr('font-size', '14px') // Increased font size
            .text('Data Flow â†’');

        // Process the data to create node positions
        const nodes = [];
        const links = [];

        // Calculate horizontal positions
        // Left section for original sources, middle for secondary, right for product
        const leftMargin = 20; // Left edge margin
        const rightMargin = width - nodeWidth - 20; // Right edge margin
        const middlePosition = width / 2 - nodeWidth / 2; // Center position for secondary sources

        // Define the diagram's horizontal layout zones more explicitly 
        const originalSourceZone = width * 0.15; // Original sources at about 15% from left
        const secondarySourceZone = width * 0.55; // Secondary sources at about 55% from left

        // Product node is always at the right
        const productNode = {
            id: data.product,
            name: data.product,
            x: rightMargin,
            y: height / 2 - nodeHeight / 2,
            type: 'product'
        };
        nodes.push(productNode);

        // Process secondary sources (middle)
        if (data.secondarySources && data.secondarySources.length > 0) {
            // Use the secondarySourceZone position
            const secondaryX = secondarySourceZone - nodeWidth / 2; // Center the node on the zone

            // If there's only one secondary source, center it vertically like the product node
            if (data.secondarySources.length === 1) {
                const node = {
                    id: data.secondarySources[0],
                    name: data.secondarySources[0],
                    x: secondaryX,
                    y: height / 2 - nodeHeight / 2, // Same vertical centering as product node
                    type: 'secondary'
                };
                nodes.push(node);

                // Link to product
                links.push({
                    source: node,
                    target: productNode
                });
            } else {
                // For multiple secondary sources, distribute them evenly
                const spacing = (height - 60) / (data.secondarySources.length + 1);
                const startY = 30; // Start further from the top

                data.secondarySources.forEach((source, i) => {
                    const node = {
                        id: source,
                        name: source,
                        x: secondaryX,
                        y: startY + (i + 1) * spacing - nodeHeight / 2,
                        type: 'secondary'
                    };
                    nodes.push(node);

                    // Link to product
                    links.push({
                        source: node,
                        target: productNode
                    });
                });
            }
        }

        // Process original sources (left)
        if (data.originalSources && data.originalSources.length > 0) {
            // Use the originalSourceZone position
            const originalBaseX = originalSourceZone - nodeWidth / 2; // Center the node on the zone
            const staggerWidth = 20; // How much to stagger horizontally

            // If there's only one original source, center it vertically like the product node
            if (data.originalSources.length === 1) {
                const node = {
                    id: data.originalSources[0],
                    name: data.originalSources[0],
                    x: originalBaseX,
                    y: height / 2 - nodeHeight / 2, // Same vertical centering as product node
                    type: 'original'
                };
                nodes.push(node);

                // Link to secondary source or product
                if (data.secondarySources && data.secondarySources.length > 0) {
                    // Link to each secondary source
                    nodes.filter(n => n.type === 'secondary').forEach(target => {
                        links.push({
                            source: node,
                            target: target
                        });
                    });
                } else {
                    // Link directly to product if no secondary sources
                    links.push({
                        source: node,
                        target: productNode
                    });
                }
            } else {
                // For multiple original sources, distribute them evenly and stagger them horizontally
                const spacing = (height - 60) / (data.originalSources.length + 1);
                const startY = 30; // Start further from the top

                data.originalSources.forEach((source, i) => {
                    // Alternate between originalBaseX and originalBaseX + staggerWidth
                    // Maintain the staggering effect
                    const staggeredX = i % 2 === 0 ? originalBaseX : originalBaseX + staggerWidth;

                    const node = {
                        id: source,
                        name: source,
                        x: staggeredX,
                        y: startY + (i + 1) * spacing - nodeHeight / 2,
                        type: 'original'
                    };
                    nodes.push(node);

                    // Link to secondary source or product
                    if (data.secondarySources && data.secondarySources.length > 0) {
                        // Link to each secondary source
                        nodes.filter(n => n.type === 'secondary').forEach(target => {
                            links.push({
                                source: node,
                                target: target
                            });
                        });
                    } else {
                        // Link directly to product if no secondary sources
                        links.push({
                            source: node,
                            target: productNode
                        });
                    }
                });
            }
        }

        // Create links (arrows)
        const arrows = g.selectAll('.arrow')
            .data(links)
            .enter()
            .append('g')
            .attr('class', 'arrow');

        // Add path for each arrow
        arrows.append('path')
            .attr('d', d => {
                const sourceX = d.source.x + nodeWidth;
                const sourceY = d.source.y + nodeHeight / 2;
                const targetX = d.target.x;
                const targetY = d.target.y + nodeHeight / 2;

                // Calculate distance between source and target
                const distance = targetX - sourceX;

                // For long distances (original to secondary), use a more gentle curve
                // For shorter distances (secondary to product), use a tighter curve
                const isLongDistance = distance > width * 0.25;

                // Adjust control points based on distance
                const controlPoint1X = sourceX + (isLongDistance ? distance * 0.25 : distance * 0.4);
                const controlPoint2X = targetX - (isLongDistance ? distance * 0.25 : distance * 0.4);

                return `M${sourceX},${sourceY} C${controlPoint1X},${sourceY} ${controlPoint2X},${targetY} ${targetX},${targetY}`;
            })
            .attr('fill', 'none')
            .attr('stroke', '#999')
            .attr('stroke-width', 2)
            .attr('marker-end', 'url(#arrowhead)');

        // Add arrowhead marker definition
        svg.append('defs').append('marker')
            .attr('id', 'arrowhead')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 8)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#999');

        // Create nodes
        const nodeGroups = g.selectAll('.node')
            .data(nodes)
            .enter()
            .append('g')
            .attr('class', d => `node ${d.type}`)
            .attr('transform', d => `translate(${d.x}, ${d.y})`)
            .on('click', function (event, d) {
                // Only navigate if it's not the product node (since we're already on the product page)
                if (d.type !== 'product') {
                    window.location.href = `/kg-registry/resource/${d.id}/${d.id}.html`;
                }
            })
            .on('mouseover', function (event, d) {
                // Highlight connected links and nodes
                d3.select(this).select('rect')
                    .attr('stroke-width', d.type === 'product' ? 4 : 2)
                    .attr('filter', 'brightness(1.1)');

                // Highlight connected arrows
                arrows.selectAll('path')
                    .attr('stroke-width', link =>
                        (link.source.id === d.id || link.target.id === d.id) ? 3 : 2
                    )
                    .attr('stroke', link =>
                        (link.source.id === d.id || link.target.id === d.id) ? '#666' : '#999'
                    );
            })
            .on('mouseout', function (event, d) {
                // Reset highlights
                d3.select(this).select('rect')
                    .attr('stroke-width', d.type === 'product' ? 3 : 1)
                    .attr('filter', null);

                // Reset arrows
                arrows.selectAll('path')
                    .attr('stroke-width', 2)
                    .attr('stroke', '#999');
            });

        // Add rectangle for each node
        nodeGroups.append('rect')
            .attr('width', nodeWidth)
            .attr('height', nodeHeight)
            .attr('rx', 5)
            .attr('ry', 5)
            .attr('fill', d => {
                if (d.type === 'product') return '#5588bb';
                if (d.type === 'secondary') return '#88bb55';
                return '#ddaa44';
            })
            .attr('stroke', '#333')
            .attr('stroke-width', d => d.type === 'product' ? 3 : 1)
            .attr('cursor', d => d.type === 'product' ? 'default' : 'pointer');

        // Add text for each node
        nodeGroups.append('text')
            .attr('x', nodeWidth / 2)
            .attr('y', nodeHeight / 2)
            .attr('text-anchor', 'middle')
            .attr('dominant-baseline', 'middle')
            .attr('fill', 'white')
            .attr('font-size', '14px') // Increased font size
            .text(d => {
                // Truncate long names
                return d.name.length > 18 ? d.name.substring(0, 15) + '...' : d.name;
            })
            .append('title')  // Add tooltip for full name
            .text(d => d.name);
            
        // Add category icons to each node
        nodeGroups.append('g')
            .attr('class', 'node-icon')
            .attr('transform', d => `translate(${nodeWidth - 22}, 10)`) // Position in top-right corner with padding
            .each(function(d) {
                const iconGroup = d3.select(this);
                const iconData = resourceIcons[d.id];
                
                if (iconData && iconData.icon) {
                    // Create icon background circle
                    iconGroup.append('circle')
                        .attr('r', 10)
                        .attr('fill', 'white')
                        .attr('opacity', 0.9);
                        
                    // Create SVG for Bootstrap icon
                    // Use foreign object to embed HTML icon
                    iconGroup.append('foreignObject')
                        .attr('width', 20)
                        .attr('height', 20)
                        .attr('x', -10)
                        .attr('y', -10)
                        .html(`<div style="width:20px;height:20px;display:flex;align-items:center;justify-content:center">
                            <i class="bi bi-${iconData.icon}" style="font-size:12px;color:#333;"></i>
                        </div>`);
                        
                    // Add tooltip with category name
                    iconGroup.append('title')
                        .text(iconData.category || 'Resource');
                }
            });

        // Add a legend (horizontal layout)
        const legend = svg.append('g')
            .attr('class', 'legend')
            .attr('transform', `translate(${width / 2 - 250}, 10)`); // Centered at the top

        const legendItems = [
            { type: 'original', label: 'Original Source' },
            { type: 'secondary', label: 'Secondary Source' },
            { type: 'product', label: 'Product' }
        ];

        const legendItemWidth = 160; // Width for each legend item

        const legendGroups = legend.selectAll('.legend-item')
            .data(legendItems)
            .enter()
            .append('g')
            .attr('class', 'legend-item')
            .attr('transform', (d, i) => `translate(${i * legendItemWidth}, 0)`); // Horizontal layout

        legendGroups.append('rect')
            .attr('width', 18) // Width of color box
            .attr('height', 18) // Height of color box
            .attr('rx', 3) // Corner radius
            .attr('ry', 3) // Corner radius
            .attr('fill', d => {
                if (d.type === 'product') return '#5588bb';
                if (d.type === 'secondary') return '#88bb55';
                return '#ddaa44';
            });

        legendGroups.append('text')
            .attr('x', 24) // Position text to the right of the rectangle
            .attr('y', 14) // Vertical alignment
            .attr('font-size', '14px') // Font size
            .text(d => d.label);
    }
</script>